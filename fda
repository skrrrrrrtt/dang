--[[

Made by griffin
Discord: @griffindoescooking
Github: https://github.com/idonthaveoneatm

FIXED VERSION - Enhanced error handling and module loading

]]--

local timeToLoad = tick()

-- Utility function for safe module loading
local function safeRequire(module, name)
    local success, result = pcall(function()
        return require(module)
    end)
    
    if not success then
        warn("[auto rank] Failed to load " .. (name or "module") .. ": " .. tostring(result))
        return nil
    end
    
    return result
end

-- Utility function for safe property access
local function safeGet(table, key, default)
    if not table then
        return default
    end
    
    local success, result = pcall(function()
        return table[key]
    end)
    
    if not success or result == nil then
        return default
    end
    
    return result
end

getgenv().isLooping = false
task.wait(0.2)
getgenv().isLooping = true
getgenv().allowedToBuyZone = true
getgenv().activeLoopedMinigame = ""
getgenv().killswitch = false
getgenv().playerStatus = ""
getgenv().selectedQuest = ""
getgenv().quests = {}
local lastZone = ""

local oldprint = print
local print = function(...)
    oldprint("[auto rank]", ...)
end
local oldwarn = warn
local warn = function(...)
    oldwarn("[auto rank]", ...)
end

-- Safe cloneref function
local cloneref = cloneref or function(obj) return obj end

-- Service references with error handling
local function getService(serviceName)
    local success, service = pcall(function()
        return cloneref(game:GetService(serviceName))
    end)
    
    if not success then
        warn("Failed to get service:", serviceName)
        return game:GetService(serviceName)
    end
    
    return service
end

local Workspace = getService("Workspace")
local Things = Workspace["__THINGS"]
local Instances = Things.Instances
local instanceContainer = Things["__INSTANCE_CONTAINER"]
local workspaceEggs = Things.Eggs
local Breakables = Things.Breakables
local Lootbags = Things.Lootbags
local Orbs = Things.Orbs

local Players = getService("Players")
local LocalPlayer = Players.LocalPlayer

-- Wait for character to load
repeat task.wait() until LocalPlayer.Character
local Character = LocalPlayer.Character
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

local LocalPlayerScripts = LocalPlayer.PlayerScripts.Scripts
local Unlocks = LocalPlayer.PlayerGui.Rank.Frame.Rewards.Items.Unlocks
local RankUpNotif = LocalPlayer.PlayerGui.GoalsSide.Frame.Quests.QuestsGradient.QuestsHolder.RankUpNotif.Title
local RankNotification = LocalPlayer.PlayerGui.GoalsSide.Frame.Bottom.OpenRewards.Notification
local RankUp = LocalPlayer.PlayerGui.RankUp
local Rebirth = LocalPlayer.PlayerGui.Rebirth

-- Safe Currency2 loading
local Currency2 = getsenv(LocalPlayerScripts.GUIs["Currency 2"])
local coinsTable = {}
if Currency2 and Currency2.init then
    local success, result = pcall(function()
        return debug.getupvalue(Currency2.init, 1)
    end)
    if success and result then
        coinsTable = result
    else
        warn("Failed to get coinsTable, using empty table")
    end
else
    warn("Currency2 or init not found")
end

-- Safe EggFrontend loading
local EggFrontend = getsenv(LocalPlayerScripts.Game["Egg Opening Frontend"])
if EggFrontend then
    EggFrontend.PlayEggAnimation = function(...)
        return
    end
end

local VirtualInputManager = getService("VirtualInputManager")
local RunService = getService("RunService")

local ReplicatedStorage = getService("ReplicatedStorage")
local Library = ReplicatedStorage.Library

-- Safe Client loading
print("Loading Client module...")
local Client = safeRequire(Library.Client, "Client")

if not Client then
    error("[auto rank] CRITICAL: Failed to load Client module! Game may not be fully loaded.")
end

print("Client module loaded successfully!")

-- Safe module loading with fallbacks
local Quests = safeRequire(Library.Types.Quests, "Quests")

-- Safe command module loading
local CurrencyCmds = safeGet(Client, "CurrencyCmds")
local QuestCmds = safeGet(Client, "QuestCmds")
local EggCmds = safeGet(Client, "EggCmds")
local ZoneCmds = safeGet(Client, "ZoneCmds")
local RebirthCmds = safeGet(Client, "RebirthCmds")
local PlayerPet = safeGet(Client, "PlayerPet")
local MasteryCmds = safeGet(Client, "MasteryCmds")
local BreakableCmds = safeGet(Client, "BreakableCmds")
local MapCmds = safeGet(Client, "MapCmds")
local FlexibleFlagCmds = safeGet(Client, "FlexibleFlagCmds")

-- Verify critical modules loaded
if not CurrencyCmds then
    warn("CurrencyCmds not found!")
end
if not QuestCmds then
    warn("QuestCmds not found!")
end
if not EggCmds then
    warn("EggCmds not found!")
end

-- Safe speed multiplier modification
if PlayerPet and PlayerPet.CalculateSpeedMultiplier then
    pcall(function()
        Client.PlayerPet.CalculateSpeedMultiplier = function(...)
            return 9e9
        end
    end)
end

local Gamepasses = safeGet(Client, "Gamepasses")
local Network = safeGet(Client, "Network")
local TabController = safeGet(Client, "TabController")

-- Safe directory loading
local zoneDirectory = safeRequire(Library.Directory.Zones, "Zones Directory")
local shovelsDirectory = safeRequire(Library.Directory.Shovels, "Shovels Directory")
local CalcEggPricePlayer = safeRequire(Library.Balancing.CalcEggPricePlayer, "CalcEggPricePlayer")

local eggPriceFunction
if CalcEggPricePlayer then
    local success, result = pcall(function()
        return debug.getupvalue(CalcEggPricePlayer, 1)
    end)
    if success then
        eggPriceFunction = result
    end
end

local getGatePrice = safeRequire(Library.Balancing.CalcGatePrice, "CalcGatePrice")
local zoneEggs = ReplicatedStorage['__DIRECTORY'].Eggs['Zone Eggs']
local zones = ReplicatedStorage.__DIRECTORY.Zones
local vipProductId = 257811346

local function goTo(coord)
    if typeof(coord) == "CFrame" then
        LocalPlayer.Character:PivotTo(coord)
    else
        coord = CFrame.new(coord.X,coord.Y,coord.Z)
        goTo(coord)
    end
end

local function leaveActiveInstance()
    if #instanceContainer.Active:GetChildren() == 1 then
        local activeInstance = instanceContainer.Active:GetChildren()[1].Name
        goTo(Instances[activeInstance]:FindFirstChild("Leave", true).CFrame)
        task.wait(0.2)
    end
end

leaveActiveInstance()

local function getMap()
    local rValue
    for _,map in ipairs(Workspace:GetChildren()) do
        if map.Name:find("Map") then
            rValue = map
            break
        end
    end
    if rValue then
        return rValue
    else
        task.wait()
        return getMap()
    end
end

print("Loading map information...")
local information = loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/lua/normal/games/PetSimulator99/table/"..getMap().Name..".lua"))()

local currencyAmounts = {}
for i,_ in coinsTable do
    currencyAmounts[i] = function()
        if CurrencyCmds and CurrencyCmds.Get then
            return CurrencyCmds.Get(i)
        end
        return 0
    end
end

local currencyIDAlternative = {
    ["Diamonds"] = "Diamond"
}
local validEnchantNames = {
    "Diamonds",
    "Treasure Hunter",
    "Lucky Eggs",
    "Walkspeed",
    "Criticals",
    "Tap Power",
    "Strong Pets"
}
local BooksRequiredPerTier = {
    5,
    5,
    5,
    7,
    7,
    7,
    7,
    7,
    10,
    10
}
local PotionsRequiredPerTier = {
    3,
    3,
    4,
    5,
    5,
    5,
    5,
    7,
    7
}
local questTypes

-- Misc Functions

local function findInTable(tbl, name)
    for index,info in tbl do
        if typeof(info) == "table" and info.Name == name then
            return tbl[index]
        elseif typeof(info) == "string" and info == name then
            return tbl[index]
        end
    end
    return nil
end

local function getNames(tbl)
    local returnTable = {}
    for _,info in tbl do
        if typeof(info) == "table" then
            table.insert(returnTable, info.Name)
        elseif typeof(info) == "string" then
            table.insert(returnTable, info)
        end
    end
    return returnTable
end

local function Fire(name, ...)
    if not Network then
        warn("Network module not available")
        return
    end
    return Network.Fire(name, ...)
end

local function Invoke(name, ...)
    if not Network then
        warn("Network module not available")
        return
    end
    return Network.Invoke(name, ...)
end

local function getNumber(str)
    return tonumber(string.match(str,'%d+'))
end

local function checkActive(name)
    if not instanceContainer.Active:FindFirstChild(name) then
        goTo(Instances[name]:FindFirstChild("Enter", true).CFrame)
    end
end

local function completeObby(obbyInfo)
    if typeof(obbyInfo) ~= "table" then
        return error("Not a table")
    end
    if typeof(obbyInfo.StartLine) ~= "CFrame" then
        if obbyInfo.StartLine:IsA("Model") then
            obbyInfo.StartLine = obbyInfo.StartLine:FindFirstChild("Part").CFrame
        else
            obbyInfo.StartLine = obbyInfo.StartLine.CFrame
        end
    end
    if typeof(obbyInfo.EndPad) ~= "CFrame" then
        obbyInfo.EndPad = obbyInfo.EndPad.CFrame
    end

    goTo(obbyInfo.StartLine + Vector3.new(0,3,0))
    task.wait(0.5)

    local common = require(instanceContainer.Active:FindFirstChild(obbyInfo.Name):FindFirstChild("Common", true))
    common.WinTimer = 0

    goTo(obbyInfo.EndPad + Vector3.new(0,3,0))
end

local function waitFor(path, object, bool)
    bool = bool or false
    repeat
        task.wait()
    until path:FindFirstChild(object, bool)
    return path:FindFirstChild(object, bool)
end

local function clickPosition(x,y)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, nil, 1)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, nil, 1)
end

-- Player Related Functions

local function getPlayerSave()
    if not Client or not Client.Save then
        warn("Client.Save not available")
        return {}
    end
    
    local success, saves = pcall(function()
        return Client.Save.GetSaves()
    end)
    
    if not success or not saves then
        warn("Failed to get player saves")
        return {}
    end
    
    return saves[LocalPlayer] or {}
end

local function getGoals()
    local save = getPlayerSave()
    return save.Goals or {}
end

local function getMaxPetsEquipped()
    local save = getPlayerSave()
    return save.MaxPetsEquipped or 8
end

local function getMaxHatch()
    if not EggCmds or not EggCmds.GetMaxHatch then
        return 1
    end
    return EggCmds.GetMaxHatch()
end

local function hasVIP()
    if not Gamepasses or not Gamepasses.Owns then
        return false
    end
    return Gamepasses.Owns(vipProductId)
end

local function getPets()
    local save = getPlayerSave()
    if save.Inventory and save.Inventory.Pet then
        return save.Inventory.Pet
    end
    return {}
end

local function getEquippedPets()
    local petTable = {}
    for petUID, pet in pairs(getPets()) do
        if pet.e then
            table.insert(petTable, petUID)
        end
    end
    return petTable
end

local function getUnequippedPets()
    local petTable = {}
    for petUID, pet in pairs(getPets()) do
        if not pet.e then
            table.insert(petTable, petUID)
        end
    end
    return petTable
end

local function getQuests()
    return getGoals()
end

local function getQuestByUID(uid)
    for _, quest in pairs(getQuests()) do
        if quest.Goal.UID == uid then
            return quest
        end
    end
    return nil
end

print("Core functions loaded successfully!")
print("loaded:", tick()-timeToLoad)

-- Print status of critical modules
print("Module Status:")
print("  CurrencyCmds:", CurrencyCmds and "✓" or "✗")
print("  QuestCmds:", QuestCmds and "✓" or "✗")
print("  EggCmds:", EggCmds and "✓" or "✗")
print("  Network:", Network and "✓" or "✗")

-- Note: The rest of the original autoRanker code continues here
-- This fixed version focuses on the initialization errors
-- You can add the rest of the quest completion logic from your original script

warn("═══════════════════════════════════════")
warn("AUTORANKER FIXED VERSION - INITIALIZED")
warn("If you see errors, wait for game to fully load")
warn("═══════════════════════════════════════")

-- Add killswitch to prevent crashes
if not CurrencyCmds or not QuestCmds or not EggCmds then
    warn("Critical modules missing! Stopping to prevent crashes.")
    warn("Try reloading the script after the game fully loads.")
    getgenv().killswitch = true
end
