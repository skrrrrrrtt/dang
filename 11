-- =========================================
-- FULL QUEST HANDLER - PS99
-- =========================================

getgenv().killswitch = false
getgenv().allowedToBuyZone = true

-- ===== SERVICES =====
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Library = ReplicatedStorage.Library
local Client = require(Library.Client)
local Network = Client.Network

local Breakables = Workspace.__THINGS.Breakables

-- ===== NETWORK SHORTCUTS =====
local function Invoke(name, ...)
    return Network.Invoke(name, ...)
end

local function Fire(name, ...)
    return Network.Fire(name, ...)
end

-- ===== SAVE =====
local function getSave()
    return Client.Save.Get()
end

-- ===== QUEST HELPERS =====
local function getQuests()
    local t = {}
    for _,v in pairs(getSave().Goals) do
        table.insert(t, {
            Goal = v,
            UID = v.UID,
            Type = tostring(v.Type),
            Stars = v.Stars or 0,
            Progress = v.Progress or 0,
            Amount = v.Amount or 0
        })
    end
    return t
end

local function questExists(uid)
    for _,v in pairs(getSave().Goals) do
        if v.UID == uid then
            return true
        end
    end
    return false
end

-- ===== ZONES =====
local function getMaxZone()
    return Client.ZoneCmds.GetMaxOwnedZone()
end

local function goToZone(zone)
    local dir = require(Library.Directory.Zones)
    local z = dir[zone]
    if not z or not z.ZoneFolder then return end
    LocalPlayer.Character:PivotTo(
        z.ZoneFolder.PERSISTENT.Teleport.CFrame + Vector3.new(0,5,0)
    )
end

local worstZone = getMaxZone()

-- ===== INVENTORY =====
local function findMiscItem(name)
    for uid,v in pairs(getSave().Inventory.Misc) do
        if type(v) == "table" and v.id == name then
            return {uid=uid, amount=v._am or 1}
        end
    end
end

-- ===== BREAKABLE FARM =====
local function getBreakablesById(id)
    local t = {}
    for _,b in ipairs(Breakables:GetChildren()) do
        if b:GetAttribute("BreakableID") and b:GetAttribute("BreakableID"):lower():find(id:lower()) then
            table.insert(t, b)
        end
    end
    return t
end

local function farmBreakables(list, uid)
    for _,b in ipairs(list) do
        if not questExists(uid) then break end
        Client.PlayerPet.SetTargetFromServer(
            Client.PlayerPet:GetAll()[1],
            "Breakable",
            b
        )
        repeat task.wait() until not b.Parent or not questExists(uid)
    end
end

-- ===== SPAWN FROM BACKPACK =====
local function spawnQuest(cfg)
    local q = cfg.quest
    local uid = q.UID

    if cfg.isBest then
        allowedToBuyZone = false
    end

    -- natural spawns first
    if not cfg.isBest then
        local found = getBreakablesById(cfg.breakId)
        if #found > 0 then
            farmBreakables(found, uid)
            if not questExists(uid) then return true end
        end
    end

    local item = findMiscItem(cfg.item)
    if not item then
        warn("Missing item:", cfg.item)
        task.wait(300)
        return false
    end

    goToZone(cfg.zone)
    task.wait(0.5)

    Invoke(cfg.remote, item.uid)
    task.wait(1)

    local spawned = getBreakablesById(cfg.breakId)
    if #spawned > 0 then
        farmBreakables(spawned, uid)
    end

    allowedToBuyZone = true
    return not questExists(uid)
end

-- ===== QUEST TYPES =====
local QuestHandlers = {

    COMET = function(q)
        return spawnQuest({
            quest = q,
            item = "Comet",
            remote = "Comet_Spawn",
            breakId = "Comet",
            zone = worstZone
        })
    end,

    BEST_COMET = function(q)
        return spawnQuest({
            quest = q,
            item = "Comet",
            remote = "Comet_Spawn",
            breakId = "Comet",
            zone = getMaxZone(),
            isBest = true
        })
    end,

    PINATA = function(q)
        return spawnQuest({
            quest = q,
            item = "Pinata",
            remote = "Pinata_Spawn",
            breakId = "Pinata",
            zone = worstZone
        })
    end,

    BEST_PINATA = function(q)
        return spawnQuest({
            quest = q,
            item = "Pinata",
            remote = "Pinata_Spawn",
            breakId = "Pinata",
            zone = getMaxZone(),
            isBest = true
        })
    end,

    COIN_JAR = function(q)
        return spawnQuest({
            quest = q,
            item = "Basic Coin Jar",
            remote = "CoinJar_Spawn",
            breakId = "CoinJar",
            zone = worstZone
        })
    end,

    BEST_COIN_JAR = function(q)
        return spawnQuest({
            quest = q,
            item = "Basic Coin Jar",
            remote = "CoinJar_Spawn",
            breakId = "CoinJar",
            zone = getMaxZone(),
            isBest = true
        })
    end,

    LUCKYBLOCK = function(q)
        return spawnQuest({
            quest = q,
            item = "Lucky Block",
            remote = "LuckyBlock_Spawn",
            breakId = "Lucky",
            zone = worstZone
        })
    end,

    BEST_LUCKYBLOCK = function(q)
        return spawnQuest({
            quest = q,
            item = "Lucky Block",
            remote = "LuckyBlock_Spawn",
            breakId = "Lucky",
            zone = getMaxZone(),
            isBest = true
        })
    end
}

-- ===== QUEST PICKER =====
local function chooseQuest()
    local best, stars = nil, -1
    for _,q in ipairs(getQuests()) do
        if QuestHandlers[q.Type] and q.Stars > stars then
            best = q
            stars = q.Stars
        end
    end
    return best
end

-- ===== MAIN LOOP =====
task.spawn(function()
    while not killswitch do
        local quest = chooseQuest()
        if quest then
            print("[QUEST]", quest.Type, quest.Progress.."/"..quest.Amount)
            pcall(QuestHandlers[quest.Type], quest)
        else
            print("No valid quests")
            task.wait(5)
        end
        task.wait(1)
    end
end)
