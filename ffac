--[[
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ADVANCED QUEST AUTO-COMPLETER V2.0
    Made for Pet Simulator 99 - ZapHub Integration
    
    Features:
    - Sequential quest completion (one by one)
    - Full AFK automation
    - Smart quest prioritization
    - Auto-recovery from errors
    - Progress tracking & notifications
    - Resource management
    - Anti-detection measures
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
]]--

local VERSION = "2.0.0"
local DEBUG_MODE = true

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- INITIALIZATION & SETUP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local startTime = tick()

-- Global flags
getgenv().questAutomation = getgenv().questAutomation or {}
local settings = getgenv().questAutomation
settings.enabled = true
settings.currentQuest = nil
settings.questQueue = {}
settings.completedQuests = {}
settings.failedQuests = {}
settings.statistics = {
    totalCompleted = 0,
    totalFailed = 0,
    totalAttempts = 0,
    uptime = 0,
    lastQuestTime = 0
}

-- Custom logging system
local function log(level, ...)
    local prefix = "[Quest Auto]"
    local levelColors = {
        ["INFO"] = "ğŸ“˜",
        ["SUCCESS"] = "âœ…",
        ["WARNING"] = "âš ï¸",
        ["ERROR"] = "âŒ",
        ["DEBUG"] = "ğŸ”"
    }
    
    local icon = levelColors[level] or "ğŸ“"
    local message = table.concat({...}, " ")
    
    if level == "DEBUG" and not DEBUG_MODE then
        return
    end
    
    print(string.format("%s %s [%s] %s", prefix, icon, level, message))
end

-- Service references (with cloneref protection)
local cloneref = cloneref or function(obj) return obj end
local Workspace = cloneref(game:GetService("Workspace"))
local Players = cloneref(game:GetService("Players"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local RunService = cloneref(game:GetService("RunService"))
local VirtualInputManager = cloneref(game:GetService("VirtualInputManager"))

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- Game-specific references
local Things = Workspace["__THINGS"]
local Instances = Things.Instances
local instanceContainer = Things["__INSTANCE_CONTAINER"]
local Breakables = Things.Breakables
local Lootbags = Things.Lootbags
local Orbs = Things.Orbs

local Library = ReplicatedStorage.Library
local Client = require(Library.Client)
local Network = Client.Network
local QuestCmds = Client.QuestCmds
local CurrencyCmds = Client.CurrencyCmds
local EggCmds = Client.EggCmds
local ZoneCmds = Client.ZoneCmds
local BreakableCmds = Client.BreakableCmds
local MapCmds = Client.MapCmds

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UTILITY FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function safeWait(duration)
    local start = tick()
    while tick() - start < duration and settings.enabled do
        task.wait()
    end
end

local function Fire(name, ...)
    return Network.Fire(name, ...)
end

local function Invoke(name, ...)
    return Network.Invoke(name, ...)
end

local function goTo(coord)
    if not settings.enabled then return end
    
    pcall(function()
        if typeof(coord) == "CFrame" then
            Character:PivotTo(coord)
        elseif typeof(coord) == "Vector3" then
            Character:PivotTo(CFrame.new(coord))
        end
    end)
    safeWait(0.1)
end

local function getPlayerSave()
    return Client.Save.GetSaves()[LocalPlayer]
end

local function getQuests()
    local playerSave = getPlayerSave()
    if playerSave and playerSave.Goals then
        return playerSave.Goals
    end
    return {}
end

local function getQuestByUID(uid)
    for _, quest in pairs(getQuests()) do
        if quest.Goal and quest.Goal.UID == uid then
            return quest
        end
    end
    return nil
end

local function getMaxZone()
    local zones = Client.WorldCmds.GetUnlockedZones()
    local maxZone = zones[1]
    for _, zone in ipairs(zones) do
        if zone.ZoneNumber > maxZone.ZoneNumber then
            maxZone = zone
        end
    end
    return maxZone.Name
end

local function getMaxPetsEquipped()
    return getPlayerSave().MaxPetsEquipped
end

local function getPets()
    return getPlayerSave().Inventory.Pet
end

local function getEquippedPets()
    local pets = {}
    for uid, pet in pairs(getPets()) do
        if pet.e then
            table.insert(pets, uid)
        end
    end
    return pets
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- QUEST DETECTION & PARSING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local questTypeHandlers = {
    ["BEST_RAINBOW_PET"] = {
        name = "Make Rainbow Pets from Best Egg",
        priority = 10,
        canComplete = true
    },
    ["BEST_GOLD_PET"] = {
        name = "Make Golden Pets from Best Egg",
        priority = 9,
        canComplete = true
    },
    ["HATCH_BEST_EGG"] = {
        name = "Hatch Best Egg",
        priority = 8,
        canComplete = true
    },
    ["BREAK_BREAKABLES"] = {
        name = "Break Breakables",
        priority = 7,
        canComplete = true
    },
    ["COIN_JAR"] = {
        name = "Collect Coin Jars",
        priority = 6,
        canComplete = true
    },
    ["COMET"] = {
        name = "Collect Comets",
        priority = 6,
        canComplete = true
    },
    ["HATCH_RARE_PET"] = {
        name = "Hatch Rare Pet",
        priority = 5,
        canComplete = true
    },
    ["BEST_SUPERIOR_MINI_CHEST"] = {
        name = "Superior Mini Chest",
        priority = 4,
        canComplete = true
    }
}

local function parseQuestDetails(quest)
    if not quest or not quest.Goal then
        return nil
    end
    
    local details = {
        uid = quest.Goal.UID,
        title = quest.Title or "Unknown Quest",
        type = quest.TypeAsString or "UNKNOWN",
        stars = quest.Goal.Stars or 0,
        progress = quest.Goal.Progress or 0,
        amount = quest.Goal.Amount or 1,
        percentage = 0,
        isCompleted = false,
        canAutoComplete = false,
        priority = 0,
        handler = nil
    }
    
    -- Calculate percentage
    if details.amount > 0 then
        details.percentage = math.floor((details.progress / details.amount) * 100)
    end
    
    details.isCompleted = details.progress >= details.amount
    
    -- Check if we can auto-complete this quest type
    local handler = questTypeHandlers[details.type]
    if handler then
        details.canAutoComplete = handler.canComplete
        details.priority = handler.priority
        details.handler = handler
    end
    
    return details
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- QUEST COMPLETION HANDLERS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function equipBestPets()
    log("INFO", "Equipping best pets...")
    
    local pets = getPets()
    local petArray = {}
    
    for uid, pet in pairs(pets) do
        table.insert(petArray, {
            uid = uid,
            power = pet.pt or 0
        })
    end
    
    table.sort(petArray, function(a, b)
        return a.power > b.power
    end)
    
    local toEquip = {}
    local maxEquip = getMaxPetsEquipped()
    
    for i = 1, math.min(maxEquip, #petArray) do
        table.insert(toEquip, petArray[i].uid)
    end
    
    if #toEquip > 0 then
        Invoke("Pets_Equip", toEquip)
        safeWait(0.5)
    end
end

local function getBestEgg()
    local eggs = ReplicatedStorage.__DIRECTORY.Eggs["Zone Eggs"]:GetChildren()
    local bestEgg = nil
    local highestZone = 0
    
    for _, egg in ipairs(eggs) do
        local eggData = require(egg)
        if eggData.currency == "Diamonds" then
            local zoneNum = tonumber(egg.Name:match("%d+")) or 0
            if zoneNum > highestZone then
                highestZone = zoneNum
                bestEgg = egg.Name
            end
        end
    end
    
    return bestEgg or "Egg 1"
end

local function hatchEggs(eggName, count)
    log("INFO", string.format("Hatching %d eggs from %s", count, eggName))
    
    local hatched = 0
    while hatched < count and settings.enabled do
        local maxHatch = EggCmds.GetMaxHatch()
        local toHatch = math.min(maxHatch, count - hatched)
        
        pcall(function()
            Invoke("Eggs_RequestHatch", eggName, toHatch)
        end)
        
        hatched = hatched + toHatch
        safeWait(2)
    end
end

local function makeGoldenPets(eggName, count)
    log("INFO", string.format("Making %d golden pets from %s", count, eggName))
    
    for i = 1, count do
        if not settings.enabled then break end
        
        -- Hatch pets
        hatchEggs(eggName, 10)
        
        -- Convert to golden
        pcall(function()
            local pets = getPets()
            local normalPets = {}
            
            for uid, pet in pairs(pets) do
                if not pet.g and not pet.r then
                    table.insert(normalPets, uid)
                    if #normalPets >= 6 then break end
                end
            end
            
            if #normalPets >= 6 then
                Invoke("Pets_MakeGolden", normalPets)
                safeWait(1)
            end
        end)
        
        safeWait(0.5)
    end
end

local function makeRainbowPets(eggName, count)
    log("INFO", string.format("Making %d rainbow pets from %s", count, eggName))
    
    for i = 1, count do
        if not settings.enabled then break end
        
        -- First make golden pets
        makeGoldenPets(eggName, 6)
        
        -- Convert to rainbow
        pcall(function()
            local pets = getPets()
            local goldenPets = {}
            
            for uid, pet in pairs(pets) do
                if pet.g and not pet.r then
                    table.insert(goldenPets, uid)
                    if #goldenPets >= 6 then break end
                end
            end
            
            if #goldenPets >= 6 then
                Invoke("Pets_MakeRainbow", goldenPets)
                safeWait(1)
            end
        end)
        
        safeWait(0.5)
    end
end

local function breakBreakables(zone, count)
    log("INFO", string.format("Breaking %d breakables in %s", count, zone))
    
    local broken = 0
    
    -- Go to zone
    goTo(Workspace.__THINGS.__INSTANCE_CONTAINER.Active:FindFirstChild(zone) and 
         CFrame.new(0, 10, 0) or 
         Workspace.__MAP.Teleports:FindFirstChild(zone).CFrame)
    
    equipBestPets()
    
    while broken < count and settings.enabled do
        local breakables = Breakables:GetChildren()
        
        for _, breakable in ipairs(breakables) do
            if not settings.enabled then break end
            
            if breakable.Name:find(zone) or zone == "any" then
                -- Send pets to breakable
                local equippedPets = getEquippedPets()
                pcall(function()
                    for _, petUID in ipairs(equippedPets) do
                        Fire("Pets: Attack Target Server", petUID, breakable)
                    end
                end)
                
                broken = broken + 1
                safeWait(0.1)
            end
            
            if broken >= count then break end
        end
        
        safeWait(0.5)
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN QUEST HANDLER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function completeQuest(questDetails)
    if not questDetails or questDetails.isCompleted then
        return false
    end
    
    log("INFO", string.format("Starting quest: %s (%s)", questDetails.title, questDetails.type))
    log("INFO", string.format("Progress: %d/%d (%d%%)", 
        questDetails.progress, questDetails.amount, questDetails.percentage))
    
    settings.currentQuest = questDetails
    settings.statistics.totalAttempts = settings.statistics.totalAttempts + 1
    
    local success = false
    local attempts = 0
    local maxAttempts = 3
    
    while attempts < maxAttempts and not questDetails.isCompleted and settings.enabled do
        attempts = attempts + 1
        
        pcall(function()
            local questType = questDetails.type
            local remaining = questDetails.amount - questDetails.progress
            
            if questType == "BEST_RAINBOW_PET" then
                makeRainbowPets(getBestEgg(), remaining)
                success = true
                
            elseif questType == "BEST_GOLD_PET" then
                makeGoldenPets(getBestEgg(), remaining)
                success = true
                
            elseif questType == "HATCH_BEST_EGG" then
                hatchEggs(getBestEgg(), remaining)
                success = true
                
            elseif questType == "BREAK_BREAKABLES" then
                breakBreakables(getMaxZone(), remaining)
                success = true
                
            elseif questType == "COIN_JAR" or questType == "COMET" then
                breakBreakables(getMaxZone(), remaining * 2) -- Break more to find special breakables
                success = true
                
            else
                log("WARNING", "Quest type not fully supported: " .. questType)
                success = false
            end
        end)
        
        -- Check if quest is completed
        safeWait(2)
        local updatedQuest = getQuestByUID(questDetails.uid)
        
        if not updatedQuest then
            log("SUCCESS", "Quest completed and removed from list!")
            success = true
            break
        else
            questDetails = parseQuestDetails(updatedQuest)
            if questDetails.isCompleted then
                log("SUCCESS", "Quest progress reached 100%!")
                success = true
                break
            end
        end
        
        if not success and attempts < maxAttempts then
            log("WARNING", string.format("Attempt %d failed, retrying...", attempts))
            safeWait(3)
        end
    end
    
    if success then
        settings.statistics.totalCompleted = settings.statistics.totalCompleted + 1
        table.insert(settings.completedQuests, questDetails.uid)
    else
        settings.statistics.totalFailed = settings.statistics.totalFailed + 1
        table.insert(settings.failedQuests, questDetails.uid)
        log("ERROR", "Failed to complete quest after " .. attempts .. " attempts")
    end
    
    settings.currentQuest = nil
    return success
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- QUEST QUEUE MANAGEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function buildQuestQueue()
    log("INFO", "Building quest queue...")
    
    local quests = getQuests()
    local queue = {}
    
    for _, quest in pairs(quests) do
        local details = parseQuestDetails(quest)
        
        if details and not details.isCompleted then
            if details.canAutoComplete then
                table.insert(queue, details)
            else
                log("WARNING", string.format("Cannot auto-complete: %s (%s)", 
                    details.title, details.type))
            end
        end
    end
    
    -- Sort by priority (highest first), then by stars
    table.sort(queue, function(a, b)
        if a.priority == b.priority then
            return a.stars > b.stars
        end
        return a.priority > b.priority
    end)
    
    settings.questQueue = queue
    
    log("INFO", string.format("Queue built with %d completable quests", #queue))
    return queue
end

local function processQuestQueue()
    local queue = buildQuestQueue()
    
    if #queue == 0 then
        log("WARNING", "No completable quests in queue!")
        return
    end
    
    log("INFO", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    log("INFO", "Starting sequential quest completion")
    log("INFO", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    for i, questDetails in ipairs(queue) do
        if not settings.enabled then
            log("WARNING", "Quest automation disabled, stopping...")
            break
        end
        
        log("INFO", string.format("[%d/%d] Processing: %s", i, #queue, questDetails.title))
        
        local success = completeQuest(questDetails)
        
        if success then
            log("SUCCESS", string.format("âœ“ Completed [%d/%d]", i, #queue))
        else
            log("ERROR", string.format("âœ— Failed [%d/%d]", i, #queue))
        end
        
        -- Wait between quests
        safeWait(2)
    end
    
    log("INFO", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    log("SUCCESS", "Quest queue processing complete!")
    log("INFO", string.format("Completed: %d | Failed: %d", 
        settings.statistics.totalCompleted, settings.statistics.totalFailed))
    log("INFO", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO COLLECTION & MAINTENANCE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

task.spawn(function()
    while settings.enabled and task.wait(0.5) do
        -- Collect lootbags
        pcall(function()
            local lootbags = {}
            for _, lootbag in ipairs(Lootbags:GetChildren()) do
                lootbags[lootbag.Name] = lootbag.Name
                lootbag:Destroy()
            end
            if next(lootbags) then
                Fire("Lootbags_Claim", lootbags)
            end
        end)
        
        -- Collect orbs
        pcall(function()
            local orbs = {}
            for _, orb in ipairs(Orbs:GetChildren()) do
                table.insert(orbs, tonumber(orb.Name))
                orb:Destroy()
            end
            if #orbs > 0 then
                Fire("Orbs: Collect", orbs)
            end
        end)
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ANTI-AFK & PROTECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pcall(function()
    LocalPlayer.PlayerScripts.Scripts.Core["Idle Tracking"].Enabled = false
end)

if getconnections then
    for _, connection in getconnections(LocalPlayer.Idled) do
        if connection["Disable"] then
            connection["Disable"](connection)
        elseif connection["Disconnect"] then
            connection["Disconnect"](connection)
        end
    end
end

local oldnamecall
oldnamecall = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    if (self.Name == "Is Real Player" or self.Name:find("Idle")) and method:lower() == "invokeserver" then
        return
    end
    return oldnamecall(self, ...)
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN LOOP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log("SUCCESS", string.format("Advanced Quest Auto-Completer V%s loaded!", VERSION))
log("INFO", string.format("Load time: %.2fs", tick() - startTime))
log("INFO", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

-- Main automation loop
task.spawn(function()
    while settings.enabled and task.wait(5) do
        settings.statistics.uptime = tick() - startTime
        
        -- Process quest queue
        processQuestQueue()
        
        -- Wait before next cycle
        log("INFO", "Waiting 30 seconds before next quest check...")
        safeWait(30)
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONTROL FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

getgenv().questAutomation.stop = function()
    settings.enabled = false
    log("WARNING", "Quest automation stopped!")
end

getgenv().questAutomation.start = function()
    settings.enabled = true
    log("SUCCESS", "Quest automation started!")
end

getgenv().questAutomation.status = function()
    log("INFO", "â•â•â• QUEST AUTOMATION STATUS â•â•â•")
    log("INFO", "Enabled: " .. tostring(settings.enabled))
    log("INFO", "Uptime: " .. math.floor(settings.statistics.uptime) .. "s")
    log("INFO", "Completed: " .. settings.statistics.totalCompleted)
    log("INFO", "Failed: " .. settings.statistics.totalFailed)
    log("INFO", "Current: " .. (settings.currentQuest and settings.currentQuest.title or "None"))
    log("INFO", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

log("INFO", "Use getgenv().questAutomation.stop() to stop")
log("INFO", "Use getgenv().questAutomation.start() to start")
log("INFO", "Use getgenv().questAutomation.status() for status")
log("INFO", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

return settings
