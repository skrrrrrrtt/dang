--[[
═══════════════════════════════════════════════════════════════
    QUEST AUTO-COMPLETER V3.0 - PRODUCTION READY
    Based on working autoRanker.lua structure
    
    ✅ Proper module loading (no Client3 errors)
    ✅ Safe error handling
    ✅ Sequential quest completion
    ✅ Full AFK automation
═══════════════════════════════════════════════════════════════
]]--

local VERSION = "3.0.0"
local startTime = tick()

-- ═══════════════════════════════════════════════════════════
-- SAFE UTILITY FUNCTIONS
-- ═══════════════════════════════════════════════════════════

local function safeRequire(module, name)
    local success, result = pcall(require, module)
    if not success then
        warn("[Quest Auto] Failed to load " .. (name or "module") .. ": " .. tostring(result))
        return nil
    end
    return result
end

local function safeGet(tbl, key, default)
    if not tbl then return default end
    local success, result = pcall(function() return tbl[key] end)
    return (success and result ~= nil) and result or default
end

-- Custom print functions
local oldprint = print
local print = function(...)
    oldprint("[Quest Auto]", ...)
end
local oldwarn = warn
local warn = function(...)
    oldwarn("[Quest Auto]", ...)
end

-- ═══════════════════════════════════════════════════════════
-- GLOBAL STATE
-- ═══════════════════════════════════════════════════════════

getgenv().questAuto = getgenv().questAuto or {}
local state = getgenv().questAuto
state.enabled = true
state.currentQuest = nil
state.completedCount = 0
state.failedCount = 0

-- ═══════════════════════════════════════════════════════════
-- SERVICE REFERENCES
-- ═══════════════════════════════════════════════════════════

local cloneref = cloneref or function(obj) return obj end

local function getService(name)
    local success, service = pcall(function()
        return cloneref(game:GetService(name))
    end)
    return success and service or game:GetService(name)
end

print("Initializing services...")

local Workspace = getService("Workspace")
local Players = getService("Players")
local ReplicatedStorage = getService("ReplicatedStorage")
local RunService = getService("RunService")

local LocalPlayer = Players.LocalPlayer
repeat task.wait() until LocalPlayer.Character
local Character = LocalPlayer.Character
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

print("Player loaded:", LocalPlayer.Name)

-- Game objects
local Things = Workspace["__THINGS"]
local Breakables = Things.Breakables
local Lootbags = Things.Lootbags
local Orbs = Things.Orbs

-- ═══════════════════════════════════════════════════════════
-- MODULE LOADING
-- ═══════════════════════════════════════════════════════════

print("Loading game modules...")

local Library = ReplicatedStorage.Library
local Client = safeRequire(Library.Client, "Client")

if not Client then
    error("[Quest Auto] Failed to load Client! Game may not be ready.")
end

-- Load command modules safely
local Network = safeGet(Client, "Network")
local CurrencyCmds = safeGet(Client, "CurrencyCmds")
local QuestCmds = safeGet(Client, "QuestCmds")
local EggCmds = safeGet(Client, "EggCmds")
local ZoneCmds = safeGet(Client, "ZoneCmds")
local BreakableCmds = safeGet(Client, "BreakableCmds")
local WorldCmds = safeGet(Client, "WorldCmds")

-- Verify critical modules
local criticalModules = {
    {"Network", Network},
    {"CurrencyCmds", CurrencyCmds},
    {"QuestCmds", QuestCmds},
    {"EggCmds", EggCmds}
}

local allLoaded = true
for _, mod in ipairs(criticalModules) do
    local status = mod[2] and "✓" or "✗"
    print(string.format("  %s: %s", mod[1], status))
    if not mod[2] then
        allLoaded = false
    end
end

if not allLoaded then
    warn("Some modules failed to load! Trying to continue anyway...")
end

-- ═══════════════════════════════════════════════════════════
-- CORE FUNCTIONS
-- ═══════════════════════════════════════════════════════════

local function Fire(name, ...)
    if not Network then return false end
    local success = pcall(Network.Fire, name, ...)
    return success
end

local function Invoke(name, ...)
    if not Network then return nil end
    local success, result = pcall(Network.Invoke, name, ...)
    return success and result or nil
end

local function goTo(coord)
    if not state.enabled then return end
    pcall(function()
        if typeof(coord) == "CFrame" then
            Character:PivotTo(coord)
        elseif typeof(coord) == "Vector3" then
            Character:PivotTo(CFrame.new(coord))
        end
    end)
    task.wait(0.1)
end

local function getPlayerSave()
    if not Client or not Client.Save then return {} end
    local success, saves = pcall(Client.Save.GetSaves)
    if not success or not saves then return {} end
    return saves[LocalPlayer] or {}
end

local function getQuests()
    local save = getPlayerSave()
    return save.Goals or {}
end

local function getQuestByUID(uid)
    for _, quest in pairs(getQuests()) do
        if quest.Goal and quest.Goal.UID == uid then
            return quest
        end
    end
    return nil
end

local function getPets()
    local save = getPlayerSave()
    if save.Inventory and save.Inventory.Pet then
        return save.Inventory.Pet
    end
    return {}
end

local function getEquippedPets()
    local equipped = {}
    for uid, pet in pairs(getPets()) do
        if pet.e then
            table.insert(equipped, uid)
        end
    end
    return equipped
end

local function getMaxPetsEquipped()
    local save = getPlayerSave()
    return save.MaxPetsEquipped or 8
end

local function getMaxZone()
    if not WorldCmds or not WorldCmds.GetUnlockedZones then
        return "Spawn"
    end
    
    local success, zones = pcall(WorldCmds.GetUnlockedZones)
    if not success or not zones or #zones == 0 then
        return "Spawn"
    end
    
    local maxZone = zones[1]
    for _, zone in ipairs(zones) do
        if zone.ZoneNumber > maxZone.ZoneNumber then
            maxZone = zone
        end
    end
    return maxZone.Name
end

-- ═══════════════════════════════════════════════════════════
-- QUEST HANDLERS
-- ═══════════════════════════════════════════════════════════

local function equipBestPets()
    local pets = getPets()
    local petArray = {}
    
    for uid, pet in pairs(pets) do
        table.insert(petArray, {uid = uid, power = pet.pt or 0})
    end
    
    table.sort(petArray, function(a, b) return a.power > b.power end)
    
    local toEquip = {}
    for i = 1, math.min(getMaxPetsEquipped(), #petArray) do
        table.insert(toEquip, petArray[i].uid)
    end
    
    if #toEquip > 0 then
        Invoke("Pets_Equip", toEquip)
        task.wait(0.5)
    end
end

local function getBestEgg()
    local success, eggs = pcall(function()
        return ReplicatedStorage.__DIRECTORY.Eggs["Zone Eggs"]:GetChildren()
    end)
    
    if not success or not eggs then
        return "Egg 1"
    end
    
    local bestEgg = "Egg 1"
    local highestZone = 0
    
    for _, egg in ipairs(eggs) do
        local eggData = safeRequire(egg)
        if eggData and eggData.currency == "Diamonds" then
            local zoneNum = tonumber(egg.Name:match("%d+")) or 0
            if zoneNum > highestZone then
                highestZone = zoneNum
                bestEgg = egg.Name
            end
        end
    end
    
    return bestEgg
end

local function hatchEggs(eggName, count)
    print(string.format("Hatching %dx %s", count, eggName))
    
    local hatched = 0
    while hatched < count and state.enabled do
        if not EggCmds or not EggCmds.GetMaxHatch then
            warn("EggCmds not available")
            break
        end
        
        local maxHatch = EggCmds.GetMaxHatch()
        local toHatch = math.min(maxHatch, count - hatched)
        
        local result = Invoke("Eggs_RequestHatch", eggName, toHatch)
        if result then
            hatched = hatched + toHatch
        end
        
        task.wait(2.5)
    end
    
    return hatched >= count
end

local function makeGoldenPets(count)
    print(string.format("Making %d golden pets", count))
    
    local made = 0
    while made < count and state.enabled do
        -- Hatch pets first
        hatchEggs(getBestEgg(), 10)
        
        -- Get normal pets
        local pets = getPets()
        local normalPets = {}
        
        for uid, pet in pairs(pets) do
            if not pet.g and not pet.r then
                table.insert(normalPets, uid)
                if #normalPets >= 6 then break end
            end
        end
        
        if #normalPets >= 6 then
            Invoke("Pets_MakeGolden", normalPets)
            made = made + 1
            task.wait(1)
        end
        
        task.wait(0.5)
    end
    
    return made >= count
end

local function makeRainbowPets(count)
    print(string.format("Making %d rainbow pets", count))
    
    local made = 0
    while made < count and state.enabled do
        -- Make golden pets first
        makeGoldenPets(6)
        
        -- Get golden pets
        local pets = getPets()
        local goldenPets = {}
        
        for uid, pet in pairs(pets) do
            if pet.g and not pet.r then
                table.insert(goldenPets, uid)
                if #goldenPets >= 6 then break end
            end
        end
        
        if #goldenPets >= 6 then
            Invoke("Pets_MakeRainbow", goldenPets)
            made = made + 1
            task.wait(1)
        end
        
        task.wait(0.5)
    end
    
    return made >= count
end

local function breakBreakables(count)
    print(string.format("Breaking %d breakables", count))
    
    equipBestPets()
    
    -- Go to max zone
    pcall(function()
        local zone = getMaxZone()
        local teleport = Workspace.__MAP.Teleports:FindFirstChild(zone)
        if teleport then
            goTo(teleport.CFrame + Vector3.new(0, 5, 0))
        end
    end)
    
    task.wait(1)
    
    local broken = 0
    while broken < count and state.enabled do
        if not Breakables then break end
        
        for _, breakable in ipairs(Breakables:GetChildren()) do
            if not state.enabled or broken >= count then break end
            
            -- Attack breakable with pets
            for _, petUID in ipairs(getEquippedPets()) do
                Fire("Pets: Attack Target Server", petUID, breakable)
            end
            
            broken = broken + 1
            
            if broken % 25 == 0 then
                print(string.format("Progress: %d/%d", broken, count))
            end
        end
        
        task.wait(0.2)
    end
    
    return broken >= count
end

-- ═══════════════════════════════════════════════════════════
-- QUEST PROCESSING
-- ═══════════════════════════════════════════════════════════

local questHandlers = {
    BEST_RAINBOW_PET = function(amount)
        return makeRainbowPets(amount)
    end,
    BEST_GOLD_PET = function(amount)
        return makeGoldenPets(amount)
    end,
    HATCH_BEST_EGG = function(amount)
        return hatchEggs(getBestEgg(), amount)
    end,
    BREAK_BREAKABLES = function(amount)
        return breakBreakables(amount)
    end,
    COIN_JAR = function(amount)
        return breakBreakables(amount * 2)
    end,
    COMET = function(amount)
        return breakBreakables(amount * 2)
    end
}

local function completeQuest(quest)
    if not quest or not quest.Goal then return false end
    
    local uid = quest.Goal.UID
    local title = quest.Title or "Unknown"
    local questType = quest.TypeAsString or "UNKNOWN"
    local progress = quest.Goal.Progress or 0
    local amount = quest.Goal.Amount or 1
    local remaining = amount - progress
    
    print("═══════════════════════════════════════")
    print("Quest:", title)
    print("Type:", questType)
    print("Progress:", progress .. "/" .. amount)
    print("═══════════════════════════════════════")
    
    state.currentQuest = title
    
    local handler = questHandlers[questType]
    if not handler then
        warn("Quest type not supported:", questType)
        return false
    end
    
    -- Execute handler
    local success = false
    for attempt = 1, 3 do
        if not state.enabled then break end
        
        print(string.format("Attempt %d/3...", attempt))
        success = handler(remaining)
        
        task.wait(2)
        
        -- Check if completed
        local updated = getQuestByUID(uid)
        if not updated then
            print("✅ Quest completed!")
            success = true
            break
        end
        
        if not success then
            warn("Attempt failed, retrying...")
            task.wait(3)
        end
    end
    
    if success then
        state.completedCount = state.completedCount + 1
    else
        state.failedCount = state.failedCount + 1
    end
    
    state.currentQuest = nil
    return success
end

local function processAllQuests()
    local quests = getQuests()
    local questList = {}
    
    -- Build quest list
    for _, quest in pairs(quests) do
        if quest.Goal and questHandlers[quest.TypeAsString] then
            local progress = quest.Goal.Progress or 0
            local amount = quest.Goal.Amount or 1
            
            if progress < amount then
                table.insert(questList, quest)
            end
        end
    end
    
    if #questList == 0 then
        print("No completable quests found!")
        return
    end
    
    -- Sort by stars
    table.sort(questList, function(a, b)
        return (a.Goal.Stars or 0) > (b.Goal.Stars or 0)
    end)
    
    print(string.format("Found %d quest(s) to complete", #questList))
    
    -- Complete quests one by one
    for i, quest in ipairs(questList) do
        if not state.enabled then
            print("Quest automation stopped!")
            break
        end
        
        print(string.format("[%d/%d] Starting quest...", i, #questList))
        local success = completeQuest(quest)
        
        if success then
            print(string.format("✓ [%d/%d] Success!", i, #questList))
        else
            print(string.format("✗ [%d/%d] Failed", i, #questList))
        end
        
        task.wait(2)
    end
    
    print("═══════════════════════════════════════")
    print("Quest Processing Complete!")
    print("Completed:", state.completedCount)
    print("Failed:", state.failedCount)
    print("═══════════════════════════════════════")
end

-- ═══════════════════════════════════════════════════════════
-- AUTO COLLECTION
-- ═══════════════════════════════════════════════════════════

task.spawn(function()
    while state.enabled do
        -- Collect lootbags
        pcall(function()
            local bags = {}
            for _, bag in ipairs(Lootbags:GetChildren()) do
                bags[bag.Name] = bag.Name
                bag:Destroy()
            end
            if next(bags) then
                Fire("Lootbags_Claim", bags)
            end
        end)
        
        -- Collect orbs
        pcall(function()
            local orbs = {}
            for _, orb in ipairs(Orbs:GetChildren()) do
                table.insert(orbs, tonumber(orb.Name))
                orb:Destroy()
            end
            if #orbs > 0 then
                Fire("Orbs: Collect", orbs)
            end
        end)
        
        task.wait(1)
    end
end)

-- ═══════════════════════════════════════════════════════════
-- ANTI-AFK
-- ═══════════════════════════════════════════════════════════

pcall(function()
    local idle = LocalPlayer.PlayerScripts.Scripts.Core["Idle Tracking"]
    if idle then idle.Enabled = false end
end)

if getconnections then
    for _, conn in getconnections(LocalPlayer.Idled) do
        if conn.Disable then conn:Disable()
        elseif conn.Disconnect then conn:Disconnect() end
    end
end

-- ═══════════════════════════════════════════════════════════
-- MAIN LOOP
-- ═══════════════════════════════════════════════════════════

print("═══════════════════════════════════════")
print("Quest Auto-Completer V" .. VERSION)
print("Loaded in " .. string.format("%.2fs", tick() - startTime))
print("═══════════════════════════════════════")

task.spawn(function()
    task.wait(2)
    
    while state.enabled do
        processAllQuests()
        
        print("Waiting 30 seconds before next check...")
        task.wait(30)
    end
end)

-- ═══════════════════════════════════════════════════════════
-- CONTROLS
-- ═══════════════════════════════════════════════════════════

state.stop = function()
    state.enabled = false
    print("⏹ Quest automation stopped!")
end

state.start = function()
    state.enabled = true
    print("▶ Quest automation started!")
end

state.status = function()
    print("═══════════════════════════════════════")
    print("Status:", state.enabled and "Running" or "Stopped")
    print("Current Quest:", state.currentQuest or "None")
    print("Completed:", state.completedCount)
    print("Failed:", state.failedCount)
    print("═══════════════════════════════════════")
end

print("")
print("Commands:")
print("  getgenv().questAuto.stop()")
print("  getgenv().questAuto.start()")
print("  getgenv().questAuto.status()")
print("")

return state
